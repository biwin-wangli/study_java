## 4.Java 设计模式和原则
软件开发不仅仅是编写代码，构建应用程序的方式对软件应用程序的成败有很大影响。当我们谈论一个成功的软件应用程序时，不仅讨论应用程序
如何执行它应该做的事情，还讨论在开发它时付出多少努力，以及它是否易于测试和维护。

创建软件应用程序是为了满足不断变化和发展的需求。一个成功的应用程序还应该提供一个钟简单的方法来扩展它以满足不断变化的期望。幸运的
是，我们不是第一个遇到这些问题的人。有一些问题已经被开发人员所发现并总结了解决方案。如果在设计和开发软件时应用一组面向对象的设计
原则和模式，则可以避免这些常见问题。

面向对象的设计原则也被称为SOLID。在设计和开发软件可以应用这些原则，以便创建易于维护和开发的程序。它们是敏捷软件开发过程的一部分。
SOLID原则包括：
- 单一职责原则
- 开闭原则
- 里氏替换原则
- 接口隔离原则
- 依赖倒置原则
- 迪米特法则

除了前面提到的设计原则外，还有面向对象的设计模式。设计模式是可以应用于常见问题的通用可重用解决方案。

---
### 单一职责原则
单一职责原则是一种面向对象的设计原则，该原则支出软件模块应该只有一个被修改的理由。在大多数情况下，编写Java代码时都会将单一职责原
则应用于类。

单一职责原则可被视为使封装工作达到最佳状态的良好实践。更改的理由是：需要修改代码。如果类需要更改的原因不止一个，那么每个类都可能
引入影响其他类的更改。当这些更改单独管理但影响同一模块时，一系列更改可能会破坏与其他更改原因相关的功能。另一方面，每个更改的职责/
理由都会增加新的依赖关系，使代码不那么简装，更难以修改。

例如：在使用数据库来持久保存对象时，假设对Car类添加方法来处理增、删、改、查的数据库操作。在这种情况下，Car不仅会封装逻辑，还会封
装数据库操作（两个职责是改变的两个原因）。因为代码时紧密耦合的，将使得我们的类更难维护和测试，Car类将取决于数据库，如果将来想要
更改数据库系统，我们必须更改Car代码，这可能会在Car逻辑中产生错误。相反，更改Car逻辑可能会在数据持久性中产生错误。

解决方案是创建两个类：一个用于封装Car逻辑（Car类），另一个用于负责持久性（CarDao）。这也是现代软件开发中常见的分层模型。

### 开闭原则
这个原则如下：```“模块、类和函数应该对扩展开放，对修改关闭。”```
应用此原则将有助于我们开发复杂而稳健的软件。我们必须想象：开发的软件，一旦我们完成了它的一部分，不应该再修改它，而是应该在它的基
础之上继续建设。如果想要改变它，不仅要测试正在改变的功能，还要测试它负责的整个功能。这涉及许多额外的资源，也会带来额外的风险。一
个模块中的更改可能会影响其他模块或整体上的功能。

因此，最好的办法是尝试在完成后保持模块不变，并通过继续和多态扩展来添加新功能。开闭原则是最重要的设计原则之一，是大多数设计模式的
基础。

### 里氏替换原则
Barbara Liskov指出，派生类型必须完全可替代其基类型。里氏替换原则（LSP）与子类型多态密切相关。基于面向对象语言中的子类型多态，派
生对象可以用其父类型替换。例如，如果有一个Car对象，它可以在代码中用做Vehicle。

里氏替换原则声明，在设计模块和类时，必须确保派生类型从行为的角度来看是可替代的。当派生类型被其父类型替换式，`其余代码就像它时子类
型那样使用它`。从这个角度来看，`派生类型应该想其父类型那样表现`，不应该破坏它的行为。这称为强行为子类型。

### 接口隔离原则
下面这句话从链接 https://www.oodesign.com/interface-segregation-principle.html 得来：**`客户端不应该依赖于它所不需要的接口。`**
实际应用中，接口隔离原则（ISP）减少了代码耦合，使软件更健壮，更易于维护和扩展。接口隔离原则最初是由Robert Martin提出的，他意识
到如果接口隔离原则被破坏，客户端被迫依赖它们不使用的接口时，代码就会变得紧密耦合，几乎不可能为其添加新功能。

为了更好地理解这一点，现在我们要需要实现一个名为Mechanic(机修工)的类。机修工修理汽车，所以我们增加了修理汽车的方法。在这个例子中，
Mechanic类依赖于ICar类，但是，Car类提供的方法超出了Mechanic需要的。这是一个糟糕的设计，因为如果我们想把汽车替换为另一辆汽车，需
腰在Mechanic类中进行更改，这违反了开闭原则。换个思路，我们可以创建一个仅公开Mechanic类所需的相关方法的接口。如下图：

![接口隔离原则](/src/main/resources/image/basics/knowledge/1-9.png) 

### 依赖倒置原则
**`高级模块不应该依赖低级模块，两者应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。`**
为了理解这个原理，我们必须解释耦合和解耦的重要概念。耦合是指软件系统的模块彼此依赖的程度。依赖度越低，维护和扩展系统就越容易。有
不同的方法来解耦系统的组件。其中一个办法是将高级逻辑与低级模块分开。这样做时，可以尝试让它们都依赖于抽象进而减少二者之间的依赖关系。
如此就可以替换或扩展其中任何一个模块而不影响其他模块。如下图：

![依赖倒置原则](/src/main/resources/image/basics/knowledge/1-10.png)

### 迪米特法则
在面向对象编程中，类之间的相互调用是很常见的，我们经常需要在一个类中访问另一个类的成员或方法。问题是，如果类经常被调用的话，我们
就要考虑到代码的可维护性和复用性。程序中代码的耦合过高可不是一件好事。我之前编程习惯也是喜欢面向过程来写代码，项目比较忙的时候我
只是要实现想要做的功能就可以了，却忽略了类之间的分化，代码写多了就看起来乱乱的，修改也很困难，容易出错。书中所说的面向接口编程即
是考虑提取出通用的接口方法来供功能类使用，以尽量减少类与类之间的耦合。

所以，<strong>迪米特法则的定义就是，如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用，如果其中一个类需要调用另一个类的某一
个方法的话，可以通过第三者转发这个调用。</strong>迪米特法则首先强调的前提是<strong>在类的结构设计上，每一个类都应当尽量降低成员的访问权限，</strong>也就是
说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。而需要公开的字段，通常就用属性来体现，这也是面向对
象的封装思想。在面向对象的设计原则中很多都是体现出面向对象的三大特性。<strong>迪米特法则其根本思想，是强调了类之间的松耦合。</strong>在程序设计时，
<strong>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</strong>


---
## 以下为设计模式目录
1.[creattional pattern(创建型模式)](creattionalpattern/5.Creattional%20Pattern.md)
 - Singleton单例模式 
 - Factory(工厂模式)
 - Builder(建造者模式)
 - Prototype(原型模式)
 - ObjectPool(对象池模式)

```
    这些模式都能够实现新的对象的实例化，提高创建对象代码的灵活性和重用性。
```
 
2.[behavioral pattern(行为型模式)](behavioralpattern/6.Behavioral%20Pattern.md)
 - Chain of Responsibility(责任链模式)
 - Command(命令模式)
 - Interpreter(解释器模式)
 - Iterator(迭代器模式) 
 - Observer(观察者模式)
 - Mediator(中介者模式)
 - Memento(备忘录模式)
 - State(状态模式)
 - Strategy(策略模式)
 - Template(模板方法模式)
 - Null Object(空对象模式)
 - Visitor(访问者模式)
 
```
    行为性模式关注对象交互、通信和控制流。大多数行为性模式欧基于组合和委托而不是继承。这些模式有助于我们以受控方式来管理对象的行为。
```