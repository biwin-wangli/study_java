## 5.3.建造者模式
当需要实例化一个复杂的类，以得到不同结构和不同内部状态的对象时，我们可以使用不同的类对它们的实例化操作逻辑分别进行封装，这些类就
被称为建造者。每当需要来自同一个类但具有不同结构的对象时，就可以通过构造另一个建造者来进行实例化。

它的概念不仅可以用于不同表现的类，还可以用于由其他对象组成的复杂对象。构造建造者来封装实例化复杂对象的逻辑，符合单一职责原则和开
闭原则。实现实例化复杂对象的逻辑被放到了单独的建造者类中。当需要具有不同结构的对象时，我们可以添加新的建造者类，从而实现对修改的
关闭和扩展的开放。

### 简单建造者
我们通过简单汽车软件的示例，应用建造者模式。首先，存在一个Car类，需要为它创建示例。通过向汽车中添加不同的组件，我们分别可以制造
电动车和汽车。CarBuilder是建造者基类，它包含了四个抽象方法。我们创建了两个具体建造者类：ElectricCarBuilder和GasolineCarBuilder。
每个建造者实现类都分别实现了CarBuilder的所有抽象方法。

[参考代码](simplebuilder/CarBuilderDirector.java)

当然现在的简单建造者其实还可以进行简化，在某些实现方式中可以移除Director类。客户端直接调用Builder也可以同样达到建造对象的目的。

### 拥有方法链的匿名建造者
如前所述，构建来自相同类但是具有不同形式的对象的最直接方法就是构建多个构造哦函数，按照不同的场景进行不同的实例化操作。使用建造者
模式避免这种情况是个不错的实践。

方法链是指通过特定方法返回当前对象（this）的一种技术。通过这种技术，可以以链的形式调用方法。
```
    public Builder setColor(){
        //set color
        return this;
    }
```

在定义了更多类似上述方法之后，可以用方法链调用它们。
```
builder.setColor("Blue")
 .setEngine("1500cc")
 .addTank("50")
 .addTransmission("auto")
 .build();
```

还可以在例子中将Car对象的建造者类构造为内部。在需要增加新客户端时，可以执行以下操作：
```
Car car = new Car.Builder.setColor("Blue")
 .setEngine("1500cc")
 .addTank("50")
 .addTransmission("auto")
 .build();
```

#### 总结
- 优点
    1. 建造者独立，易扩展。 
    2. 便于控制细节风险。

- 缺点
    1. 产品必须有共同点，范围有限制。 
    2. 如内部变化复杂，会有很多的建造类。