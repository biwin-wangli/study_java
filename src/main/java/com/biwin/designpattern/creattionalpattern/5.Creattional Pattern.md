## 创建型模式（Creattional Pattern）
创建型模式主要用于处理对象的创建问题，我们主要介绍以下内容：
- 单例模式
- 工厂模式
- 建造者模式
- 原型模式
- 对象池模式

----
### 单例模式
单例模式，顾名思义，用来保证一个对象只能创建一个实例，除此之外，它还提供了对实例的全局访问方法。单例模式的实现非常简单，只由单个
类组成。为确保单例实例的唯一性，所有的单例构造器都要被声明为私有的(private)，再通过声明静态(static)方法实现全局访问获得该单例实例。

    public class BaseSingleton {
        private static BaseSingleton baseSingleton;
        private BaseSingleton(){}
        public static BaseSingleton getInstance(){
            if(null == baseSingleton) {
                baseSingleton = new BaseSingleton();
            }
            return baseSingleton;
        }
        public void doSomething(){
            System.out.println("Something is Done.");
        }
    }

在getInstance方法中，需要判断实例是否为空。如果实例不为空，则表示该对象在之前已被创建；否则，用心的构造器创建它。经过这些操作，
无论是哪种情况，实例都不再为空，可以返回实例对象。

#### 同步锁单例
单例模式的实现代码简单且高效，但还需要注意一种特殊情况，在多线程应用中使用这种模式，如果实例为空，可能存在两个线程同时调用getInstance
方法的情况。如果发生这种情况，第一个线程会首先使用新构造器实例化单例对象，同时第二个线程也会检查单例实例是否为空，由于第一个线程
还没完成单例对象的实例化操作，所以第二个线程会发现这个实例是空的，也会开始实例化单例对象。

要解决这个问题很简单，我们只需要创建一个代码块来检查实例是否空线程安全。可以通过以下两种方式来实现。
- 向getInstance方法的声明中添加synchronized关键字以保证其线程安全：

    public static synchronized Singleton getInstance();

- 用synchronized代码块包装if(instance == null)条件。在这一环境中使用synchronized代码块时，需要制定一个对象来提供锁，Singeton.class对象就起这种作用。如以下代码片段所示：

    synchronized (SingletonSync.class){
      if(instance == null){
          instance = new SingetonSync2();
      }
    }
    

#### 下一节
[]()Casper