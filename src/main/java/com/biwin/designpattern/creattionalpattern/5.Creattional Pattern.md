## 5.创建型模式（Creattional Pattern）
创建型模式主要用于处理对象的创建问题，我们主要介绍以下内容：
- 单例模式
- 工厂模式
- 建造者模式
- 原型模式
- 对象池模式

----
### [单例模式](singleton/5.1.Singleton.md)
自Java语言推广使用依赖，单例模式（Singleton pattern）就是最常用的设计模式，它具有易于理解、使用便捷等特点。有时单例模式会过渡使
用或在不合适的场景下使用，造成弊大于利的后果，因此，单例模式有时被认为是一种反模式。但是很多情况下单例模式是不可或缺的。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。

### [工厂模式](factory/5.2.Factory.md)
工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

### [建造者模式](builder/5.3.Builder.md)
建造者模式与其他创建型模式一样服务于相同的目标，只不过它出于不同的原因，通过不同的方式实现。在开发复杂的应用程序时，代码往往会变
得非常复杂。类会封装更多的功能，类的结构也会变得更加复杂。随着功能量的增加，就需要涵盖更多的场景，从而需要构建更多不同的类。

### [原型模式](prototype/5.4.Prototype.md)
用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，
则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时
候更新数据库，以此来减少数据库调用。

不通过 new 关键字来产生一个对象，而是通过对象拷贝来实现的模式就叫做原型模式，这个模式的核心是一个clone()方法，通过这个方法进行
对象的拷贝，Java 提供了一个 Cloneable 接口来标示这个对象是可拷贝的，为什么说是“标示”呢？翻开 JDK 的帮助看看 Cloneable 是一个方
法都没有的，这个接口只是一个标记作用，在 JVM 中具有这个标记的对象才有可能被拷贝，所以覆盖了clone()方法就可以了。

在 clone()方法上增加了一个注解@Override， 没有继承一个类为什么可以重写呢？在 Java 中所有类的父类是Object 类，每个类默认都是继承
了这个类，所以这个用上@Override是非常正确的。原型模式虽然很简单，但是在 Java 中使用原型模式也就是 clone 方法还是有一些注意事项的：
对象拷贝时，类的构造函数是不会被执行的。 一个实现了 Cloneable 并重写了 clone 方法的类 A,有一个无参构造或有参构造 B，通过 new 关
键字产生了一个对象 S，再然后通过 S.clone()方式产生了一个新的对象 T，那么在对象拷贝时构造函数 B 是不会被执行的， 对象拷贝时确实构
造函数没有被执行，这个从原理来讲也是可以讲得通的，Object 类的 clone 方法的 原理是从内存中（具体的说就是堆内存）以二进制流的方式
进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。

### [对象池模式](objectpool/5.5.ObjectPool.md)
对象池模式，或者称为对象池服务，通过循环使用对象，减少资源在初始化和释放时的昂贵损耗。
注意：这里的“昂贵”可能是时间效益（如性能），也可能是空间效益（如并行处理），在大多的情况下，“昂贵”指性能。
简单的说，在需要时，从池中提取；不用时，放回池中，等待下一个请求。典型例子是连接池和线程池，这是我们开发中经常接触到的。

#### 下一节
[]()