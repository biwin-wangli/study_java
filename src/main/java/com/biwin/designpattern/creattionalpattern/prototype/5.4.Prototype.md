## 5.4.原型模式
原型模式看似复杂，实际上它只是一种克隆对象的方法。现在实例化对象操作并不特别耗费性能，那么为什么还需要对象克隆呢？在以下几种情况
下，确实需要克隆哪些已经经过实例化的对象：

- 依赖于外部资源或硬件密集型操作进行新对象的创建的情况。
- 获取相同对象在相同状态的拷贝而无须进行重复获取状态操作的情况。
- 在不确定所属具体类时需要对象的实例的情况。

我们还是先看下UML类图：如下

![原型模式](/src/main/resources/image/designpattern/creattionalpattern/1-14.png)

注意：final 类型修饰的成员变量不能进行深度拷贝

#### 总结
- 优点
    1. 性能提高。 
    2. 逃避构造函数的约束。

- 缺点
    1. 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 
    2. 必须实现 Cloneable 接口。
    
#### 使用场景
1. 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
2. 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
3. 隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。
4. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
5. 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；
6.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式先产生出一个包含

大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。

[参考代码(浅克隆)](PrototypePatternDemo.java)

[参考代码(深克隆)](Person.java)