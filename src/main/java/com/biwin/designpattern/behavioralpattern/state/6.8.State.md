## 状态模式
我们知道每个类都承担一项职责。当向对象添加功能时，我们可能意识到需要保存其内部状态，以便能够在以后阶段恢复它。如果直接在类中实现
这样的功能，这个类可能会变得太复杂，最终可能会违反单一职责原则。同时，封装阻止我们直接访问需要记忆的对象的内部状态。

### 目的&实现
允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

备忘录模式依赖三个类 - Originator、Memento 和 Caretaker。UML如下：

![备忘录模式](/src/main/resources/image/designpattern/behavioralpattern/2-7.png)

- Originator(发起者)：发起者是我们需要记住状态的对象，以便在某个时刻恢复它。
- Caretaker(管理者)：这是负责触发发起者的变化或触发发起者返回先前状态的动作的类。
- Memento(备忘录)：这是负责存储发起者内部状态的类。备忘录提供了两种设置和获取状态的方法，但这些方法应该对管理者隐藏。

[参考代码](MementoTest.java) 

### 总结
- 优点 
    1. 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 
    2. 实现了信息的封装，使得用户不需要关心状态的保存细节。

- 缺点
    1. 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。