## 7.2.代理模式
每当使用Enterprise或Spring bean，模拟实例和实现AOP时，对具有相同接口的另一个对象进行RMI或JNI调用，或直接/间接使用
java.lang.reflect.Proxy时，就会涉及一个代理对象。它的目的是为真实对象提供一个代理对象，二者占用的内存一样。在调用前后执行其他操
作时，由代理对象代理原对象的工作。

代理模式可以分为以下几类：
- 远程代理：就是将工作委托给远程对象（不同的进程，不同的机器）来完成，例如企业Bean。通过手动或自动使用JNI包装现有的非Java旧代码
（如C/C++）是远程代理模式的一种形式，它使用句柄（C/C++中的指针）来访问实际对象。
- 保护代理：该模式主要进行安全/权限检查。
- 缓存代理：它使用存储来加速调用。一个很好的例子是Spring中@Cacheable方法，它能够缓存特定参数的方法的结果，在次调用该方法时，会
直接从缓存返回先前计算的结果，而不调用实际代码。
- 虚拟和智能代理：这种模式为方法增加了功能，例如记录性能指标（创建@Aspect，使用@Pointcut表示所需方法并定义@Around建议）或进行延
迟初始化。

>  **适配器模式和代理模式之间的主要却别在于代理模式提供了完全相同的接口。装饰器模式增强了接口，而适配器模式更改了接口。**

### 目的&实现
代理模式提供一个实际对象的代理，以便更好地控制实际对象。它是一个功能行为类似实际对象的句柄，从而使客户端代码能够像使用实际对象一
样使用它。如下UML类图模拟了代理模式，由于实际对象和代理对象都实现了相同的接口，他们之间可以相互转换。

![代理模式](/src/main/resources/image/designpattern/structuralpattern/3-2.png)

从实现图中可以看到代理模式包含以下几项要素：
- Subject（共同接口）：客户端使用的现有接口。
- RealSubject（真实对象）：真实对象的类。
- ProxySubject（代理对象）：代理类。

[参考代码](ProxyPatternTest.java)

### 总结
- 优点
    1. 职责清晰。 
    2. 高扩展性。 
    3. 智能化。

- 缺点
    1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
    2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。